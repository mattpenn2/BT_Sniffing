import logging
from typing import List, Dict, Optional
from .nvd_client import NVDClient

logger = logging.getLogger(__name__)


class VulnerabilityMapper:
    """
    Maps discovered Bluetooth devices to known vulnerabilities
    from the NVD database.
    """
    
    def __init__(self, nvd_client: Optional[NVDClient] = None):
        """
        Initialize vulnerability mapper
        
        Args:
            nvd_client: NVD client instance (creates new one if not provided)
        """
        self.nvd_client = nvd_client or NVDClient()
        self.bluetooth_cves = []
        self._load_bluetooth_vulnerabilities()
    
    def _load_bluetooth_vulnerabilities(self):
        """Load known Bluetooth vulnerabilities"""
        logger.info("Loading Bluetooth vulnerabilities...")
        
        # Try to load from cache first
        cached = self.nvd_client.load_cached_cves('bluetooth_cves', max_age_days=7)
        
        if cached:
            self.bluetooth_cves = cached
        else:
            # Fetch from NVD and cache
            self.bluetooth_cves = self.nvd_client.get_recent_bluetooth_cves(days=730)  # Last 2 years
            self.nvd_client.cache_cves(self.bluetooth_cves, 'bluetooth_cves')
        
        logger.info(f"Loaded {len(self.bluetooth_cves)} Bluetooth CVEs")
    
    def map_device_to_vulnerabilities(self, device_data: Dict) -> List[Dict]:
        """
        Map a device to known vulnerabilities
        
        Args:
            device_data: Device information from fingerprinting
            
        Returns:
            List of applicable vulnerabilities
        """
        vulnerabilities = []
        
        manufacturer = device_data.get('manufacturer', '').lower()
        device_category = device_data.get('device_category', '').lower()
        version_info = device_data.get('version_info', {})
        
        logger.info(f"Mapping vulnerabilities for device: {device_data.get('mac_address')}")
        
        # Generic Bluetooth vulnerabilities (apply to all devices)
        generic_vulns = self._find_generic_bluetooth_vulns()
        vulnerabilities.extend(generic_vulns)
        
        # Manufacturer-specific vulnerabilities
        if manufacturer and manufacturer != 'unknown':
            manufacturer_vulns = self._find_manufacturer_vulns(manufacturer)
            vulnerabilities.extend(manufacturer_vulns)
        
        # Category-specific vulnerabilities
        if device_category and device_category != 'unknown':
            category_vulns = self._find_category_vulns(device_category)
            vulnerabilities.extend(category_vulns)
        
        # OS-specific vulnerabilities
        os_version = version_info.get('os_version', '')
        if os_version and 'unknown' not in os_version.lower():
            os_vulns = self._find_os_vulns(os_version)
            vulnerabilities.extend(os_vulns)
        
        # Remove duplicates
        unique_vulns = self._deduplicate_vulns(vulnerabilities)
        
        # Calculate risk scores
        for vuln in unique_vulns:
            vuln['risk_score'] = self._calculate_risk_score(vuln, device_data)
        
        # Sort by risk score (highest first)
        unique_vulns.sort(key=lambda x: x.get('risk_score', 0), reverse=True)
        
        logger.info(f"Found {len(unique_vulns)} applicable vulnerabilities")
        return unique_vulns
    
    def _find_generic_bluetooth_vulns(self) -> List[Dict]:
        """Find generic Bluetooth vulnerabilities that apply to all devices"""
        generic_keywords = ['bluetooth', 'ble', 'bluez', 'bluetooth low energy']
        
        generic_vulns = []
        for cve in self.bluetooth_cves:
            description = cve.get('description', '').lower()
            
            # Check if it's a generic Bluetooth vulnerability
            if any(keyword in description for keyword in generic_keywords):
                # Check if it's not too specific to a vendor/product
                if not self._is_vendor_specific(description):
                    generic_vulns.append(cve.copy())
        
        return generic_vulns
    
    def _find_manufacturer_vulns(self, manufacturer: str) -> List[Dict]:
        """Find vulnerabilities specific to a manufacturer"""
        manufacturer_vulns = []
        
        for cve in self.bluetooth_cves:
            description = cve.get('description', '').lower()
            affected_products = cve.get('affected_products', [])
            
            # Check description
            if manufacturer.lower() in description:
                manufacturer_vulns.append(cve.copy())
                continue
            
            # Check affected products (CPE strings)
            for product in affected_products:
                if manufacturer.lower() in product.lower():
                    manufacturer_vulns.append(cve.copy())
                    break
        
        return manufacturer_vulns
    
    def _find_category_vulns(self, category: str) -> List[Dict]:
        """Find vulnerabilities specific to device category"""
        category_keywords = {
            'smartphone': ['android', 'ios', 'mobile', 'phone'],
            'computer': ['windows', 'macos', 'linux', 'desktop', 'laptop'],
            'iot': ['iot', 'smart home', 'smart device'],
            'audio': ['headphone', 'speaker', 'audio'],
            'wearable': ['watch', 'fitness', 'wearable']
        }
        
        keywords = category_keywords.get(category, [])
        category_vulns = []
        
        for cve in self.bluetooth_cves:
            description = cve.get('description', '').lower()
            
            if any(keyword in description for keyword in keywords):
                category_vulns.append(cve.copy())
        
        return category_vulns
    
    def _find_os_vulns(self, os_version: str) -> List[Dict]:
        """Find OS-specific vulnerabilities"""
        os_keywords = []
        
        if 'android' in os_version.lower():
            os_keywords = ['android']
        elif 'ios' in os_version.lower():
            os_keywords = ['ios', 'iphone']
        elif 'macos' in os_version.lower():
            os_keywords = ['macos', 'mac os']
        elif 'windows' in os_version.lower():
            os_keywords = ['windows']
        
        os_vulns = []
        for cve in self.bluetooth_cves:
            description = cve.get('description', '').lower()
            
            if any(keyword in description for keyword in os_keywords):
                os_vulns.append(cve.copy())
        
        return os_vulns
    
    def _is_vendor_specific(self, description: str) -> bool:
        """Check if vulnerability is vendor-specific"""
        vendor_keywords = ['apple', 'google', 'samsung', 'microsoft', 'intel', 
                          'qualcomm', 'broadcom', 'mediatek']
        
        return any(vendor in description for vendor in vendor_keywords)
    
    def _deduplicate_vulns(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Remove duplicate vulnerabilities"""
        seen = set()
        unique = []
        
        for vuln in vulnerabilities:
            cve_id = vuln.get('cve_id')
            if cve_id not in seen:
                seen.add(cve_id)
                unique.append(vuln)
        
        return unique
    
    def _calculate_risk_score(self, vulnerability: Dict, device_data: Dict) -> float:
        """
        Calculate risk score for a vulnerability on a specific device
        
        Args:
            vulnerability: CVE data
            device_data: Device information
            
        Returns:
            Risk score (0.0 to 10.0)
        """
        # Start with CVSS score
        cvss_score = vulnerability.get('cvss_score', 5.0)
        
        # Adjust based on device confidence
        confidence = device_data.get('confidence_score', 0.5)
        
        # Lower confidence means more uncertain risk
        risk_score = cvss_score * confidence
        
        # Boost score for critical/high severity
        severity = vulnerability.get('severity', 'UNKNOWN').upper()
        if severity == 'CRITICAL':
            risk_score *= 1.2
        elif severity == 'HIGH':
            risk_score *= 1.1
        
        # Cap at 10.0
        return min(risk_score, 10.0)
    
    def get_vulnerability_summary(self, vulnerabilities: List[Dict]) -> Dict:
        """
        Generate summary statistics for vulnerabilities
        
        Args:
            vulnerabilities: List of vulnerabilities
            
        Returns:
            Summary dictionary
        """
        if not vulnerabilities:
            return {
                'total_count': 0,
                'by_severity': {},
                'highest_risk': None,
                'average_cvss': 0.0
            }
        
        # Count by severity
        severity_count = {}
        cvss_scores = []
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'UNKNOWN')
            severity_count[severity] = severity_count.get(severity, 0) + 1
            
            cvss = vuln.get('cvss_score')
            if cvss:
                cvss_scores.append(cvss)
        
        # Calculate average CVSS
        avg_cvss = sum(cvss_scores) / len(cvss_scores) if cvss_scores else 0.0
        
        # Find highest risk
        highest_risk = max(vulnerabilities, key=lambda x: x.get('risk_score', 0))
        
        return {
            'total_count': len(vulnerabilities),
            'by_severity': severity_count,
            'highest_risk': highest_risk,
            'average_cvss': round(avg_cvss, 2),
            'critical_count': severity_count.get('CRITICAL', 0),
            'high_count': severity_count.get('HIGH', 0)
        }
    
    def update_vulnerability_database(self):
        """Update the vulnerability database with latest CVEs"""
        logger.info("Updating vulnerability database...")
        
        # Fetch latest Bluetooth CVEs
        self.bluetooth_cves = self.nvd_client.get_recent_bluetooth_cves(days=730)
        
        # Cache the results
        self.nvd_client.cache_cves(self.bluetooth_cves, 'bluetooth_cves')
        
        logger.info(f"Database updated with {len(self.bluetooth_cves)} CVEs")
