import requests
import time
import logging
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import json
import os

logger = logging.getLogger(__name__)


class NVDClient:
    """
    Client for interacting with the NVD API to fetch CVE data.
    API Documentation: https://nvd.nist.gov/developers/vulnerabilities
    """
    
    BASE_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    
    def __init__(self, api_key: Optional[str] = None, cache_dir: str = "data/vulnerability_cache"):
        """
        Initialize NVD client
        
        Args:
            api_key: Optional NVD API key for higher rate limits
            cache_dir: Directory to cache vulnerability data
        """
        self.api_key = api_key
        self.cache_dir = cache_dir
        self._ensure_cache_directory()
        
        # Rate limiting: 5 requests per 30 seconds without API key
        # 50 requests per 30 seconds with API key
        self.rate_limit = 50 if api_key else 5
        self.rate_window = 30  # seconds
        self.request_times = []
    
    def _ensure_cache_directory(self):
        """Create cache directory if it doesn't exist"""
        if not os.path.exists(self.cache_dir):
            os.makedirs(self.cache_dir)
            logger.info(f"Created cache directory: {self.cache_dir}")
    
    def _rate_limit_check(self):
        """Check and enforce rate limiting"""
        now = time.time()
        
        # Remove requests outside the time window
        self.request_times = [t for t in self.request_times if now - t < self.rate_window]
        
        # Check if we're at the limit
        if len(self.request_times) >= self.rate_limit:
            sleep_time = self.rate_window - (now - self.request_times[0])
            if sleep_time > 0:
                logger.warning(f"Rate limit reached. Sleeping for {sleep_time:.2f} seconds")
                time.sleep(sleep_time)
        
        self.request_times.append(now)
    
    def _make_request(self, params: Dict) -> Optional[Dict]:
        """
        Make API request to NVD
        
        Args:
            params: Query parameters
            
        Returns:
            API response as dictionary or None on error
        """
        self._rate_limit_check()
        
        headers = {}
        if self.api_key:
            headers['apiKey'] = self.api_key
        
        try:
            response = requests.get(self.BASE_URL, params=params, headers=headers, timeout=30)
            
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 403:
                logger.error("API key invalid or rate limit exceeded")
            elif response.status_code == 404:
                logger.warning("No results found")
            else:
                logger.error(f"API request failed: {response.status_code}")
            
            return None
            
        except requests.exceptions.RequestException as e:
            logger.error(f"Request failed: {e}")
            return None
    
    def search_cves(self, keyword: str, results_per_page: int = 20) -> List[Dict]:
        """
        Search for CVEs by keyword
        
        Args:
            keyword: Search keyword (e.g., "bluetooth", "android")
            results_per_page: Number of results per page
            
        Returns:
            List of CVE dictionaries
        """
        logger.info(f"Searching CVEs for keyword: {keyword}")
        
        params = {
            'keywordSearch': keyword,
            'resultsPerPage': results_per_page
        }
        
        response = self._make_request(params)
        
        if response and 'vulnerabilities' in response:
            cves = []
            for vuln in response['vulnerabilities']:
                cve_data = self._parse_cve(vuln)
                cves.append(cve_data)
            
            logger.info(f"Found {len(cves)} CVEs for '{keyword}'")
            return cves
        
        return []
    
    def get_cve_by_id(self, cve_id: str) -> Optional[Dict]:
        """
        Get specific CVE by ID
        
        Args:
            cve_id: CVE identifier (e.g., "CVE-2023-1234")
            
        Returns:
            CVE dictionary or None
        """
        logger.info(f"Fetching CVE: {cve_id}")
        
        params = {
            'cveId': cve_id
        }
        
        response = self._make_request(params)
        
        if response and 'vulnerabilities' in response and len(response['vulnerabilities']) > 0:
            return self._parse_cve(response['vulnerabilities'][0])
        
        logger.warning(f"CVE not found: {cve_id}")
        return None
    
    def search_by_vendor_product(self, vendor: str, product: str = None, 
                                 version: str = None) -> List[Dict]:
        """
        Search CVEs by vendor/product/version
        
        Args:
            vendor: Vendor name (e.g., "apple", "google")
            product: Product name (e.g., "iphone_os", "android")
            version: Version number (optional)
            
        Returns:
            List of CVE dictionaries
        """
        # Construct CPE match string
        cpe_match = f"cpe:2.3:*:*:{vendor}:"
        if product:
            cpe_match += f"{product}:"
            if version:
                cpe_match += f"{version}:"
        
        logger.info(f"Searching CVEs for CPE: {cpe_match}")
        
        params = {
            'cpeName': cpe_match,
            'resultsPerPage': 50
        }
        
        response = self._make_request(params)
        
        if response and 'vulnerabilities' in response:
            cves = [self._parse_cve(v) for v in response['vulnerabilities']]
            logger.info(f"Found {len(cves)} CVEs for {vendor}/{product}")
            return cves
        
        return []
    
    def get_recent_bluetooth_cves(self, days: int = 365) -> List[Dict]:
        """
        Get recent Bluetooth-related CVEs
        
        Args:
            days: Number of days to look back
            
        Returns:
            List of CVE dictionaries
        """
        # Calculate date range
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        
        logger.info(f"Fetching Bluetooth CVEs from last {days} days")
        
        params = {
            'keywordSearch': 'bluetooth',
            'pubStartDate': start_date.strftime('%Y-%m-%dT00:00:00.000'),
            'pubEndDate': end_date.strftime('%Y-%m-%dT23:59:59.999'),
            'resultsPerPage': 100
        }
        
        response = self._make_request(params)
        
        if response and 'vulnerabilities' in response:
            cves = [self._parse_cve(v) for v in response['vulnerabilities']]
            logger.info(f"Found {len(cves)} recent Bluetooth CVEs")
            return cves
        
        return []
    
    def _parse_cve(self, vuln_data: Dict) -> Dict:
        """
        Parse CVE data into simplified format
        
        Args:
            vuln_data: Raw vulnerability data from API
            
        Returns:
            Parsed CVE dictionary
        """
        cve = vuln_data.get('cve', {})
        
        cve_id = cve.get('id', 'Unknown')
        
        # Get description
        descriptions = cve.get('descriptions', [])
        description = descriptions[0].get('value', 'No description') if descriptions else 'No description'
        
        # Get CVSS scores
        metrics = cve.get('metrics', {})
        cvss_score = None
        severity = 'UNKNOWN'
        
        # Try CVSS v3.1 first, then v3.0, then v2.0
        for cvss_version in ['cvssMetricV31', 'cvssMetricV30', 'cvssMetricV2']:
            if cvss_version in metrics and len(metrics[cvss_version]) > 0:
                cvss_data = metrics[cvss_version][0].get('cvssData', {})
                cvss_score = cvss_data.get('baseScore')
                severity = cvss_data.get('baseSeverity', 'UNKNOWN')
                break
        
        # Get published and modified dates
        published = cve.get('published', '')
        last_modified = cve.get('lastModified', '')
        
        # Get references
        references = []
        for ref in cve.get('references', []):
            references.append({
                'url': ref.get('url', ''),
                'source': ref.get('source', '')
            })
        
        # Get CPE configurations (affected products)
        affected_products = []
        configurations = cve.get('configurations', [])
        for config in configurations:
            for node in config.get('nodes', []):
                for cpe_match in node.get('cpeMatch', []):
                    if cpe_match.get('vulnerable', False):
                        affected_products.append(cpe_match.get('criteria', ''))
        
        return {
            'cve_id': cve_id,
            'description': description,
            'cvss_score': cvss_score,
            'severity': severity,
            'published_date': published,
            'last_modified': last_modified,
            'references': references,
            'affected_products': affected_products
        }
    
    def cache_cves(self, cves: List[Dict], cache_key: str):
        """
        Cache CVE data to local file
        
        Args:
            cves: List of CVE dictionaries
            cache_key: Identifier for cache file
        """
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        
        try:
            with open(cache_file, 'w') as f:
                json.dump({
                    'cached_at': datetime.now().isoformat(),
                    'cves': cves
                }, f, indent=2)
            
            logger.info(f"Cached {len(cves)} CVEs to {cache_file}")
        except Exception as e:
            logger.error(f"Failed to cache CVEs: {e}")
    
    def load_cached_cves(self, cache_key: str, max_age_days: int = 7) -> Optional[List[Dict]]:
        """
        Load cached CVE data
        
        Args:
            cache_key: Identifier for cache file
            max_age_days: Maximum age of cache in days
            
        Returns:
            List of CVEs or None if cache invalid/not found
        """
        cache_file = os.path.join(self.cache_dir, f"{cache_key}.json")
        
        if not os.path.exists(cache_file):
            return None
        
        try:
            with open(cache_file, 'r') as f:
                data = json.load(f)
            
            # Check cache age
            cached_at = datetime.fromisoformat(data['cached_at'])
            age = datetime.now() - cached_at
            
            if age.days > max_age_days:
                logger.info(f"Cache expired (age: {age.days} days)")
                return None
            
            logger.info(f"Loaded {len(data['cves'])} CVEs from cache")
            return data['cves']
            
        except Exception as e:
            logger.error(f"Failed to load cached CVEs: {e}")
            return None
